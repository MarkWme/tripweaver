name: tripweaver-ci

on:
  push:
    branches: [main]
    # Skip full CI for dependency-only changes (fast-validate handles those)
    paths-ignore:
      - 'api/requirements.txt'
      - 'frontend/package.json'
  pull_request:
    # Always run on PRs for comprehensive validation
  workflow_dispatch:
    # Allow manual triggering

env:
  REGISTRY: ${{ vars.JFROG_REGISTRY }}         # e.g. <org>.jfrog.io
  IMG_API: ${{ vars.JFROG_REGISTRY }}/tripweaver-api
  IMG_FE:  ${{ vars.JFROG_REGISTRY }}/tripweaver-frontend
  IMG_SEED: ${{ vars.JFROG_REGISTRY }}/tripweaver-seedgen
  # Enable command summaries for GitHub Actions integration
  # JFROG_CLI_COMMAND_SUMMARY_OUTPUT_DIR: ${{ runner.temp }}/jfrog-command-summaries

jobs:
  debug-oidc:
    runs-on: ubuntu-latest
    steps:
      - name: Get OIDC token for JFrog
        id: oidc
        run: |
          URL="${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=${{ vars.JF_URL }}"
          TOKEN_JSON=$(curl -s -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" "$URL")
          TOKEN=$(echo "$TOKEN_JSON" | jq -r '.value')
          echo "token=$TOKEN" >> "$GITHUB_OUTPUT"

      - name: Show claims
        run: |
          echo "${{ steps.oidc.outputs.token }}" \
          | cut -d. -f2 | tr '_-' '/+' | base64 -d 2>/dev/null | jq
  build:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
      security-events: write
    steps:
      - uses: actions/checkout@v4

      # ---- JFrog CLI (OIDC) ----
      - id: jf-setup
        uses: jfrog/setup-jfrog-cli@v4
        with:
          version: latest
          oidc-provider-name: ${{ vars.JF_OIDC_PROVIDER }}
        env:
          JF_URL: ${{ vars.JF_URL }}
          JF_GIT_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - run: |
          echo "JFrog CLI configured and ready"
          jf -v
          jf rt ping

      # ---- Configure Artifactory repos for build modules ----
      # Python (pip → module api-pip) - packages installed in Docker build
      - name: Configure pip for Artifactory
        working-directory: api
        env:
          JF_PYPI_REPO: ${{ vars.JF_PYPI_REPO }}   # virtual (e.g. pypi)
        run: |
          jf pip-config --repo-resolve "$JF_PYPI_REPO" || true
          echo "Pip configured to use Artifactory repository: $JF_PYPI_REPO"

      # npm (frontend → module fe-npm)
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: NPM install and resolve via Artifactory
        working-directory: frontend
        env:
          ARTIFACTORY_NPM_REGISTRY: ${{ vars.ARTIFACTORY_NPM_REGISTRY }} # https://<org>.jfrog.io/artifactory/api/npm/npm/
        run: |
          jf npm-config --global=true --repo-resolve "$ARTIFACTORY_NPM_REGISTRY" || true
          jf npm install --module fe-npm  # Generates package-lock.json fresh
          rm -rf node_modules  # keep image slim; we only needed dependency resolution

      # NuGet (.NET → module seed-nuget)
      - name: NuGet resolve via Artifactory
        working-directory: tools/seedgen
        env: 
          ARTIFACTORY_NUGET_SOURCE: ${{ vars.ARTIFACTORY_NUGET_SOURCE }} # https://<org>.jfrog.io/artifactory/api/nuget/nuget
        run: |
          jf dotnet-config --repo-resolve "$ARTIFACTORY_NUGET_SOURCE" || true
          jf dotnet restore --module seed-nuget

      # ---- Build & push images (attach to SAME build) ----
      - uses: docker/setup-buildx-action@v3
      - name: Docker login
        run: echo "${{ steps.jf-setup.outputs.oidc-token }}" >/dev/null || true  # no-op; jf handles auth
      - name: Build+push API
        run: |
          jf docker build -t $IMG_API:${{ github.sha }} -f api/Dockerfile api
          jf docker push  $IMG_API:${{ github.sha }}
          echo "API_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' $IMG_API:${{ github.sha }} | cut -d'@' -f2)" >> $GITHUB_ENV
      - name: Build+push Frontend
        run: |
          jf docker build -t $IMG_FE:${{ github.sha }} -f frontend/Dockerfile frontend
          jf docker push  $IMG_FE:${{ github.sha }}
          echo "FE_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' $IMG_FE:${{ github.sha }} | cut -d'@' -f2)" >> $GITHUB_ENV
      - name: Build+push Seedgen
        run: |
          jf docker build -t $IMG_SEED:${{ github.sha }} -f tools/seedgen/Dockerfile tools/seedgen
          jf docker push  $IMG_SEED:${{ github.sha }}
          echo "SEED_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' $IMG_SEED:${{ github.sha }} | cut -d'@' -f2)" >> $GITHUB_ENV

      # ---- SBOM (CycloneDX only; attach to build) ----
      - name: Install Syft
        run: curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
      - name: Generate+upload SBOMs
        run: |
          mkdir -p _sbom
          syft $IMG_API@${API_DIGEST}   -o cyclonedx-json > _sbom/api.cdx.json
          syft $IMG_FE@${FE_DIGEST}     -o cyclonedx-json > _sbom/frontend.cdx.json
          syft $IMG_SEED@${SEED_DIGEST} -o cyclonedx-json > _sbom/seed.cdx.json
          jf rt u "_sbom/*.json" "tripweaver-sbom/sbom/tripweaver-ci/${{ github.run_id }}/"

      # ---- Sign images (Cosign keyless). Optional: set COSIGN_EXPERIMENTAL=1 if needed ----
      - uses: sigstore/cosign-installer@v3.7.0
      - name: Sign images
        env: { COSIGN_YES: "true" }
        run: |
          cosign sign $IMG_API@${API_DIGEST}
          cosign sign $IMG_FE@${FE_DIGEST}
          cosign sign $IMG_SEED@${SEED_DIGEST}

      # ---- Xray scanning Docker images first (faster) ----
      - name: Xray scan Docker images
        run: |
          echo "Scanning Docker images for vulnerabilities..."

          echo "Scanning API image..."
          jf docker scan $IMG_API:${{ github.sha }} --fail=false --format=table

          echo "Scanning Frontend image..."
          jf docker scan $IMG_FE:${{ github.sha }} --fail=false --format=table

          echo "Scanning Seedgen image..."
          jf docker scan $IMG_SEED:${{ github.sha }} --fail=false --format=table

      # ---- Publish build-info before build-info scanning (slower, done last) ----
      - name: Publish build-info for scanning
        run: |
          jf rt build-collect-env
          jf rt build-add-git
          jf rt build-publish

      # ---- Xray scanning build-info (build indexing enabled via enable-build-indexing.sh) ----
      - name: Xray scan build-info
        run: |
          echo "Scanning build: $JFROG_CLI_BUILD_NAME #$JFROG_CLI_BUILD_NUMBER"
          jf build-scan "$JFROG_CLI_BUILD_NAME" "$JFROG_CLI_BUILD_NUMBER" --fail=false
